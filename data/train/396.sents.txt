Determining node positions is essential for many next-generation network functionalities.
Previous localization algorithms lack cor-rectness guarantees or require network density higher than required for unique localizability.
In this paper, we describe a class of algorithms for fine-grained localization called Sweeps.
Sweeps correctly finitely localizes all nodes in bilateration networks.
Sweeps also handles angle measurements and noisy measurements.
We demonstrate the practicality of our algorithm through extensive simulations on a large number of networks, upon which it consistently localizes one-thousand-node networks of average degree less than five in less than two minutes on a consumer PC.
Determining node positions or possible positions is an essential requirement for many next-generation network functionalities.
For example, in crisis response, it is important to know the precise position or possible positions of an emergency in order to take prompt action.
For some inventory applications or ubiquitous computing, it is necessary to precisely identify one particular item out of a large number of items in close proximity.
Although the importance of precise localization has long been well-recognized, no entirely satisfactory solution yet exists for the anticipated networks of thousands of resource-constrained, and possibly mobile nodes.Naive approaches are easily seen to be inadequate.
While it may be possible to manually furnish each node with its position in small and static networks, this approach is clearly infeasible in the envisioned large-scale networks.
Another straightforward approach is Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee.
MobiCom'06, September [23][24][25][26]2006 to equip each node with GPS, enabling it to determine its position by communicating with GPS satellites.
However, there are several potential problems with this approach.
First, GPS hardwarerequirements may be excessive for resource-constrained nodes in large-scale networks.
Next, GPS-reliant localization will not be robust in the presence of obstructions such as dense foliage and tall buildings blocking communication with satellites, and has great difficulty operating indoors or underground.
Another potential pitfall in designing a GPS-reliant localization layer is that it will be dependent on the GPS infrastructure, which may come under attack or be made unavailable by its owner.The difficulties in the obvious approaches have led researchers to address the problem in alternative technological settings.
A promising class of approach for precise localization is fine-grained localization (e.g., [1,7,8,11,13,21,28,29,30,31,32,34,35,36,39]).
In such approaches, only some of the network nodes called beacons or anchors are endowed with their positions through GPS or manual configuration, and all nodes measure the distance between themselves and nearby nodes using hardware ranging techniques.
The essential aim of fine-grained localization is to propagate the knowledge of the positions of only a few nodes to the positions of many using relationships in position expressed by pairwise distance information.Fine-grained localization algorithms can be broadly classified into two categories: the global approaches, which localize all nodes simultaneously (e.g., [8]), and the sequential approaches, which localize nodes in some order (e.g., [28,35]).
A representative global approach is semi-definite programming (SDP) [8,7].
This approach works well for a dense network.
However, it may generate faulty positions in sparse networks where global incorrect flip configurations cannot be escaped.
Another technique to compute all node positions simultaneously is multi-dimensional scaling (MDS) (e.g., [21,25,36]).
However, the quality of MDS position estimates depends crucially on the quality of the estimate of the complete distance matrix.
The problem of producing good estimates of the complete distance matrix for non-convex network deployments is still an unsolved problem.
Although important work was done by Lim and Hou [24] addressing this issue, since their approach utilizes anchors, the problem still stands for cases in which anchors are not distributed uniformly, or there are no anchors at all.
Overall, the global approaches treat all nodes equally without identifying correctly localizable nodes.
Given the inherent NP-hardness of localization [4], it is unlikely that the global approaches can avoid large errors for some nodes.
Such errors can happen particularly in sparse networks or dense networks with sparse sub-regions.
However, as the authors of [28] pointed out, "for many applications, missing localization information for a known set of nodes is preferential to incorrect information for an unknown set.
"One way to guarantee correctness is to localize nodes sequentially.
A representative sequential approach is robust quadrilaterals [28].
This approach processes nodes one by one, and in the process, prunes distance measurements that are deemed unreliable.
Although this approach ensures the absence of systematic localization errors, it succeeds in localizing only a small portion of potentially localizable nodes.
It fails on sparse networks, and does not succeed in extending a localized region past areas of local sparsity.In this paper, we study fine-grained localization with the following requirements: 1) compute positions without potential systematic errors; 2) localize uniquely localizable nodes with high probability, even in networks that are not uniformly dense; and 3) for nodes that cannot be uniquely localized but can be localized up to a set of possibilities, output the set of possible positions whenever feasible.
It is easy to envision that outputting the set of all possible positions of a node can be useful in many applications.
We call this generalized localization objective finite localization, as opposed to unique localization, upon which most previous localization techniques focus.In this paper, we provide a class of simple algorithms referred to as Sweeps which satisfies the above design requirements.
In prior work [15,16], the idea of sweeping through a network in a sequential fashion was proposed and preliminary results were obtained.
In this paper, we improve the computational complexity of sweeping using consistent position combinations and shell sweeps, and extend sweeping to handle angle and noisy measurements.
By design, our algorithm does not fall victim to large localization errors due to flip configurations.
We prove that our algorithm finitely localizes all nodes in a large class of sparse network called bilateration networks.
For uniformly random networks, we demonstrate that in the worst case, our algorithm uniquely localizes at least 90% of all uniquely localizable nodes, when the average connectivity degree of the network nodes varies from 3 to 13; except in the transition phase when the average connectivity degree of the network nodes is between 6 and 7.5, it localizes above 95% of all uniquely localizable nodes.
As comparison, iterated trilateration sometime localizes only 40% of the uniquely localizable nodes.
For regular networks deployed to provide spatial coverage, at average connectivity degree 6, our algorithm localizes 90% of uniquely localizable nodes, while iterated trilateration localizes less than 10%.
The tradeoff for achieving high localizability at low density is that the worst-case time complexity of our algorithm could be exponential in the number of nodes.
However, we show that at a given density, typically, the running time of our algorithm grows linearly with increasing number of nodes.
It localizes more than 95% of uniquely localizable nodes of a network with one-thousand nodes with average connectivity degree less than five in two minutes on a consumer PC with an Intel CPU of 2.8 GHz.
Our algorithm is not essentially centralized, in that it does not require any global information.
Thus, our algorithm can be extended to distributed settings.
We also extend our algorithm to handle angle and noisy measurements.As a demonstration on the applicability of our algorithm, we investigate localization in a mobile network in which individual nodes use controlled mobility to optimize spatial coverage.
We show that extremely sparse networks with just enough constraints for unique localizability are produced in this setting, and that our algorithm succeeds in localizing these sparse networks feasibly and predictably 1 .
The rest of the paper is structured as follows.
In Section 2 we give useful terms and definitions, and review background results.
In Section 3 we describe our algorithms and in Section 4 we prove its correctness on bilateration networks.
In Section 5 we present our simulation results on realistic networks.
In this section, we also present our case-study of a coverage-optimizing mobile network and the success of Sweeps Localization on this network class.
In Section 6 we cover related work.
We conclude and discuss future work in Section 7.
In this section, we briefly review the theoretical background of localization.
For a more thorough exposition of the concepts which follow, we refer the interested reader to [14,3].
In our network model, we assume that nodes are located at distinct physical locations in some region of space.
Let N be a network in R d with nodes labeled 1, 2, . . ., n. Let π(i) denote the position of node i. Suppose the positions of some nodes are known.
The nodes whose positions are known are also called anchors.Below we assume that nodes have some means by which to measure the distance between themselves and their neighboring nodes.
Later in this paper, we also consider the case of angle measurements.
If the distance between nodes i and j is known, then let dij denote that distance.
Note that the distance between any two anchors is known since the positions of all of the anchors are known.
By a consistent assignment of the network N is meant any function α : {1, 2, . . . , n} → R d where α(a) = π(a) whenever node a is an anchor, and for all i, j ∈ {1, 2, . . . , n}, ||α(i) − α(j)|| = dij if the distance between nodes i and j is known.If there exists exactly one consistent assignment of N, we say that the network N is uniquely localizable, or simply localizable.
A node v of N is said to be localizable if for all consistent assignments α for N, we have that α(v) = π(v).
There are networks in which the positions of some can be varied continuously while simultaneously satisfying all distance constraints.
Such networks have an infinite number of possible position assignments, and are called flexible.
Networks that are not flexible are called rigid.
If a network has a finite number of consistent assignments, it is called finitely localizable.
Rigid networks have a finite number of possible position assignments.
Rigidity can be combinatorially characterized generically in the plane by Laman's condition [22], which expresses the welldistributedness of distance constraints over the graph.
The multiple possible position assignments of a rigid network in the plane are due to flip ambiguities and discontinuous flex ambiguities.
It is not known whether or not in 3D there could be other discontinuous ambiguities.
In a flip ambiguity, a set of nodes is reflected across a line between a separating pair of nodes.
An example is shown in Fig- ure 1(a).
A discontinuous flex ambiguity occurs when the network becomes flexible upon removal of a single edge and then subject to a continuous deformation over which at some configuration differing from the original, the removed constraint becomes satisfied and can then be reinserted.
An example is shown in Figure 1(b).
We are interested in localization in the generic sense, and as such, a graph-theoretic property for almost all problem instances.
A multi-point p = {p1, . . . , pn} in d-dimensional space is a set of n points in R d labeled p1, . . . , pn.
A multi-point p is generic if the coordinates of points in p are algebraically independent over the rationals.
If we assume precise distance measurements, we can neglect such degeneracies as vanishingly unlikely in random networks.Two multi-points p = {p1, . . . , pn} and q = {q1, . . . , qn} of n points are congruent if for all i, j ∈ {1, . . . , n}, the distance between pi and pj is equal to the distance between qi and qj .
A point formation of n points at a multi-point p = {p1, . . . , pn} consists of p and a simple undirected graph G with vertex set V = {1, . . . , n}, and is denoted by (G, p).
If (i, j) is an edge in G, then the length of edge (i, j) in the point formation (G, p) is the distance between pi and pj.
A network with n nodes is modeled by a point formation (G, p), where each node corresponds to exactly one vertex of G, and vice versa, with (i, j) being an edge of G if i and j are distinct and the distance between the corresponding nodes is known, and p = {p1, . . . , pn} where pi is the position of the node corresponding to vertex i.
We say that G is the graph of the network, and p is the multi-point of the network.
Since almost all multi-points are generic, we have that the multi-points of networks are almost always generic.
Henceforth, we shall consider mainly networks with generic multi-points.
However, degeneracy may become important when distance measurements are imprecise.
We will return to this topic in Section 5.
It was shown in [3,14] that a network is localizable if the grounded graph of the network consisting of a vertex for each network node and an edge for every distance measurement and every pair of anchors, is globally rigid (triconnected and remains rigid upon removal of any single edge).
Specifically, a point formation (G, p) is globally rigid in R d if p and q are congruent multi-points in R d whenever (G, p) and (G, q) have the same edge lengths.
A graph G is said to be generically globally rigid in R d if (G, p) is globally rigid in R d whenever p in R d is generic.
There are a number of efficient algorithms for determining if a graph is generically globally rigid in R 2 .
Since almost all multi-points are generic, we have that (G, p) is globally rigid in R 2 for almost all multi-points p in R 2 if G is generically globally rigid in R 2 .
A graph that is generically globally rigid in R 2 is said to be minimally generically globally rigid in R 2 if the removal of any edge causes the graph to not be generically globally rigid in R 2 .
The computational complexity associated with localizing uniquely localizable networks has been shown to be NP-hard even for unitdisk networks [4].
Intuitively, this complexity is linked with exponential growth in possible network configurations due to flip ambiguities present before all constraints are taken into consideration.
In spite of the NP-hardness of localization, as we shall see in this paper, there are large classes of networks for which localization is efficiently computable.One type of efficiently localizable network is trilateration networks.
A graph has a trilateration ordering with seeds v1, v2 and v3 if its vertices can be ordered as v1, v2, v3, . . . , vn so that v1, v2 and v3 induce a complete subgraph, and each vi, i > 3, is adjacent to at least three vertices vj where j < i. Graphs with trilateration orderings are called trilateration graphs and are generically globally rigid in R 2 .
We say a network is a trilateration network if its graph has a trilateration ordering.A graph has a bilateration ordering with seeds v1, v2 and v3 if its vertices can be ordered as v1, v2, . . . , vn so that v1 and v2 are adjacent, and each vi, i > 2, is adjacent to at least two vertices vj where j < i. Graphs with bilateration orderings are called bilateration graphs, and a network is called a bilateration network if its graph is a bilateration ordering.
An example bilateration graph with vertex set V is a wheel graph, if there exists a vertex v ∈ V such that v is adjacent to all other vertices in V, and vertices in V − {v} can be ordered as v1, . . . , vm such that each vi, i ∈ {2, . . . , m − 1}, is only adjacent to vi−1 and vi+1, and v1 is adjacent to vm.
Figure 2 shows an example of a wheel graph with 6 vertices.
In this paper, we say a network is sparse if its average node degree is less than 10.
Iterative localization algorithms based on trilateration have difficulty localizing sparse networks, but we will show that our algorithm localizes most localizable nodes in sparse networks.
The idea of the Sweeps algorithm is related to simple iterated trilateration.
In iterated trilateration, an initial set of three nodes is fixed and used to define a coordinate system.
At each stage of the algorithm, there is a set of localized nodes and a set of unlocalized nodes.
If an unlocalized node has distance measurements to at least three localized nodes, its position is calculated and it is added to the set of localized nodes.
Simple iterated trilateration is sub-optimal in that there are many localizable networks which it cannot localize.
Only networks called trilateration networks are completely localized by iterated trilateration [3,14].
Wheel networks ( Figure 2) are an example of a class of localizable but non-trilateration networks [3,14].
We will see that all generic wheel networks can be localized by the Sweeps algorithm, which we now describe.
The objective of our Sweeps algorithm is to localize a much larger class of networks than previously possible.
In the basic Sweeps algorithm, as in iterated trilateration, an initial set of three nodes is fixed.
At each stage of the algorithm, there is a set of finitely localized nodes whose positions have been determined up to a finite set of possibilities, and a set of unlocalized nodes.
We say that the finitely localized nodes have been "swept".
If an unlocalized node has distance measurements to at least two finitely localized nodes, it calculates all possible positions for itself based on the consistent combinations of these nodes' positions.
Two node positions pu and pv are consistent if for every node w whose set of possible positions Pw is used in computing both pu and pv, only a single possibility pw ∈ Pw is used.
In other words, if pu and pv both depend on a position of w, they must depend on the same possibility.
This is illustrated in Figure 3.
Let us consider a run of Sweeps on the wheel network shown in Figure 2.
We use vi to refer to node i in the figure.
We fix the coordinates of v0, v1, and v2 so that v0 = (0, 0), v1 = (a, 0) and v2 = (b, c) for some a, c > 0.
Knowledge of the lengths of v2v3 and v0v3 establishes the position of v3 with a binary ambiguity.
For each of these possible positions for v3, knowledge of the lengths v3v4 and v0v4 will establish the position of v4 with a binary ambiguity, making four possibilities in all.
Lastly, we obtain eight possible positions of v5.
For an analogously labelled wheel network of arbitrary size k + 1, in a similar fashion, we obtain the positions of v6, v7, . . . , v k with 2 4 , 2 5 , . . . , 2 k−2 ambiguities.
However, v k is also connected to v0 and v1.
Knowledge of the associated lengths resolves the ambiguity in the position of v k .
This in turn allows resolution of the ambiguity in v k−1 , v k−2 , . . . , v3, and in this way the unique localization of the network is established.We have seen that if we run Sweeps on the wheel network, we run into exponential growth in possible node positions.
One challenge facing the Sweeps algorithm is to avoid this effect if possible.
To this end, we eliminate possibilities as soon as it is possible to do so.
After a node is added to the set of swept nodes, all of its distance measurements to other already swept nodes are considered, potentially eliminating some of its possible positions, and some of the possible positions of already swept nodes.
Note that there exist examples, such as wheel networks, for which there are no chances to eliminate any possibilities until the very last edge is added.We further reduce the growth in possible positions by choosing a particular sweep ordering.
In the so-called shell Sweeps, we perform a breadth-first sweep in which at each stage, all nodes having a distance measurement to at least two already swept nodes are placed earlier in the ordering than all other nodes.
In localizing the wheel network of Figure 2, this would result in the order v0, v1, v2, v3, v5, v4, with 1, 1, 1, 2, 2, and 4 respectively being the maximum number of possible positions, instead of the ordering v0, v1, v2, v3, v4, v5 of the naive method, where we have 1, 1, 1, 2, 4, and 8 respective maximum possible node positions.
In typical random and regular networks, this approach dramatically reduces the number of possibilities that the algorithm has to maintain.The complete shell sweeps algorithm is shown in Figure 4.
The correctness of the algorithm will be analyzed in Section 4.
Sweeps succeeds in finitely localizing all nodes in bilateration networks [15,16], which as we saw in Section 2 are defined analogously to trilateration networks [3,14].
While bilateration networks are rigid, they are not necessarily globally rigid nor are globally rigid networks necessarily bilateration networks In Figure 5 there are two example of globally rigid graphs that are not bilat- eration graphs.
We have never seen the graph in part (a) of the figure arise in practice, and the union of two globally rigid subnetworks connected by a non-bilaterable "bridge" as in part (b) is uncommon.
We will exhibit in Section 5 that many globally rigid networks, especially globally rigid unit disk networks, are also in fact bilateration networks.
This is significant because globally rigid bilateration networks are uniquely localized by Sweeps.
if (Consistent(pv, pw)) [p u1 , p u2 ] = CircleIntersection(pv , pw, duv, duw) p u1 .
AncestorsByDepth = MergeAncestors(pu, pv) p u2 .
AncestorsByDepth = p w1 .
AncestorsByDepth Pu.add(p u1 , p u2 ) u.setPositions The Sweeps algorithm is very well suited to incorporate angle measurements in addition to distance information.
An angle between two edges along with their lengths determines the distance between their distinct endpoints.
Therefore, measuring the angle between every two distance measurements incident on a node is equivalent to "doubling" the network, i.e., adding distance measurements between all nodes within two hops of each other.Doubling a connected network gives a bilateration network [3,14,2], so this means that the Sweeps algorithm will succeed in finitely localizing a connected network with angle information.
Furthermore, doubling a 2-edge connected network gives a globally rigid network, so it follows that doubling a 2-edge connected network gives a globally rigid bilateration network that Sweeps will uniquely localize.As 2-edge connectivity is a mild condition on the connectivity of a network relative to the high density requirements of trilaterationbased localization, this application of Sweeps could be very useful.
An example scenario is an urban setting, where sensors could be deployed along streets in a minimally 2-edge connected fashion and still localize.
The Sweeps algorithm can be extended to handle noisy measurements.
As noted in previous studies (e.g., [28]), the larger the noise present in distance measurements, the more likely to occur are degenerate cases in which distance measurements to three nodes do not uniquely determine a node's position.
This means that the basic Sweeps algorithm cannot succeed in always choosing the correct flip configuration.
Because of this, we cannot eliminate potential node positions as we did before, or else we risk eliminating the correct configuration.
We found that elimination criteria which use constraints on the position of only a single node result in correct positions being discarded with high frequency.What we do instead is to consider groups of nodes together when deciding among flip configurations.
Not all groups however have uniquely determined positions.
Thus, we apply rigidity theory and identify groups of uniquely localizable nodes by identifying globally rigid components.Specifically, we extend the shell Sweeps algorithm to partition nodes in each shell into two groups: those which are uniquely localizable when combined with constraints to nodes in previous shells, and those which are not.
After nodes in a shell are finitely localized, all consistent combinations of positions of uniquely localizable nodes are produced.
For each of these configurations, we calculate the squared discrepancy between the induced inter-node distances and the measured distances, which measures the stress of the configuration,P (i,j)∈Egr (|xi − xj| − ˆ dij ) 2 ,where Egr is the set of edges in the globally rigid component, xi and xj are computed possible positions for nodes i and j, andˆdijandˆ andˆdij is the noisy measured distance between them.
We use a simple approach in which we first eliminate the highest-stress configurations, and then choose the remaining configuration which violates the fewest unitdisk graph constraints.
A different criterion could be used, but we have found this condition to work best among those tested.
This approach works because each stage (shell) of the shell Sweep typically expands radially outward from previous shells.
In general, an incorrectly flipped point tends to lie "inside" an earlier shell, at a position where it would have edges which it in fact does not have to previously swept nodes, while the correct position lies "outside", where it is less likely to violate unit-disk graph constraints.The complete algorithm handling noisy measurements is outlined in Figure 6.
Let N be a localizable network in the plane with nodes labeled 1, . . . , n. Let π(1), . . . , π(n) denote the positions of nodes 1, . . . , n respectively.
Suppose the set of node positions is generic, and more specifically, no three nodes are collinear.
Let G = (V, E ) be the graph of N, and assume G has a bilateration ordering.
In the following we will show how the Sweeps algorithm can compute a position for each node such that all known inter-node distances are satisfied.
The actual node positions can then be obtained by a Euclidean transformation using anchor positions.For v ∈ V, let N (v) denote the set of all nodes adjacent to v in G.
The Sweeps algorithm begins by selecting a bilateration ordering [v] = v1, . . . , vn of G. Let S denote the set of seed nodes of [v]: S = {v1, v2, v3}.
An ordering of all of the nodes of G is called a sweep of N just in case all of the nodes in S precede all of the other nodes, and there is at least one node in V − S that is adjacent to a node preceding it in the ordering.
An assignment is any function α : U → R 2 where U ⊂ V. Let D(α) denote the domain of the assignment α.
Two assignments α and α 񮽙 are said to be consistent with each other if α(u) = α 񮽙 (u) for all u ∈ D(α) ∩ D(α 񮽙 ).
Note that α and α 񮽙 are consistent with each other if D(α) ∩ D(α 񮽙 ) = ∅.
For p ∈ R 2 and a positive real number r, let C(p, r) denote the circle of radius r centered at p.The Sweeps algorithm selects the first sweep to be the bilateration ordering [v] and computes the first sweep by computing a set S(vi, 1) for each i ∈ {1, . . . , n} as follows.
Assign a position to each of the seed nodes v1, v2, v3 so that the known inter-node distances among them are satisfied.
For seed node vi, i ∈ {1, 2, 3}, let pv i denote the position assigned to vi; define αp v i to be the assignment with domain {vi} where αp v i (vi) = pv i ; define S(vi, 1) = {(pv i , αp v i )}.
The Sweeps algorithm recursively computes the sets S(vi, 1), i > 3, as follows.
For vi, i > 3, let M(vi) = N (vi)∩{v1, . . . , vi−1}.
Since [v] is a bilateration ordering, M(vi), i > 3, must be a set of at least two elements.
Let u1, . . . , um be the elements of M(vi).
Let S(vi, 1) be the set of all (p, αp) computed as follows:1.
There exist (pu j , αp u j ) ∈ S(uj, 1), j ∈ {1, . . . , m}, such that αp u j is consistent with αp u h for all j, h ∈ {1, . . . , m}, and p ∈ T j∈{1,...,m} C(pu j , du j v i ).2.
Let αp(vi) = p. For w ∈ S h∈{1,...,m} D(αp u h ), we let αp(w) = αp u j (w) where w ∈ D(αp u j ) for some j ∈ {1, . . . , m}.
Note that αp is well defined because αp u j is consistent with αp u h for all j, h ∈ {1, . . . , m}, and only S(uj, 1), j ∈ {1, . . . , m}, are used in computing S(vi, 1).
It is straightforward to show that S(u, 1) is non-empty and consists of a finite number of elements for each u ∈ V.
We say Sweeps has computed the first sweep when all S(vi, 1), i ∈ {1, . . . , n}, are computed.Sweeps computes the kth sweep, k > 1, by selecting a sweep [u] distinct from the previous k − 1 sweeps, and computing a set S(ui, k) for each i ∈ {1, . . . , n} as follows.
Note that [u] does not have to be a bilateration ordering if it is not the first sweep.
LetM(ui) = N (ui) ∩ {u1, . . . , ui−1}.
Let S(ui, k) = S(ui, k − 1) if i ∈ {1, 2, 3} or M(ui) = ∅.
Consider ui, i > 3, where M(ui) is non-empty.
Let w1, . . . , wm be the elements of M(ui).
Let S(ui, k) be the set of all (p, αp) computed as follows:1.
There exist (p, α 񮽙 p ) ∈ S(ui, k − 1) for some α 񮽙 p , and also (pw j , αp w j ) ∈ S(wj, k), j ∈ {1, . . . , m}, such that the assignments α 񮽙 p and αp w j , j ∈ {1, . . . , m}, are pairwise consistent, and p ∈ T j∈{1,...,m} C(pw j , du i w j ).
x ∈ D(α 񮽙 p ) ∪ S h∈{1,...,m} D(αp w h ), let αp(x) = α 񮽙 p (x) if x ∈ D(α 񮽙 p ), and let αp(x) = αp w j (x) if x ∈ D(αp w j ) for some j ∈ {1, . . . , m}.
Note that αp is well defined because the assignments α 񮽙 p and αp w j , j ∈ {1, . . . , m}, are pairwise consistent, and only S(ui, k− 1) and S(wj, k), j ∈ {1, . . . , m}, are used in computing S(ui, k).
It is straightforward to show that S(w, k) is non-empty and consists of a finite number of elements for each w ∈ V.
We say Sweeps has computed the k-th sweep when all S(ui, k), i ∈ {1, . . . , n}, are computed.A path from node a to b in G is a sequence of nodes a1, . . . , a l where a is adjacent to a1, ai is adjacent to ai+1, i ∈ {1, . . . , l−1}, and a l is adjacent to b. Let [w] = w1, . . . , wn be a sweep.
For wj ∈ V−S, define G(wj , [w]) as the subgraph of G induced by wj and all nodes wi, i < j, where wi is adjacent to wj or there exists a path wi 1 , . . . , wi m from wi to wj such that i < i k < i k+1 < j for k ∈ {1, . . . , m− 1}.
If node wj is in G(wi, [w]), then we write wj ∈ G(wi, [w]).
LEMMA 1.
Suppose Sweeps has computed k sweeps where k ≥ 1, and let [w] be the kth sweep.
Suppose (pu, αp u ) ∈ S(u, k) where u ∈ V − S.1.
If node v ∈ G(u, [w]), then v ∈ D(αp u ).
G(u, [w]), then ||αp u (a) − αp u (b)|| = d ab .3.
If v ∈ S and v ∈ D(αp u ), then αp u (v) = pv, where pv is the position assigned to v. Consider u ∈ V − S. Let N1(u) denote the set of nodes in V adjacent to u. Suppose for some integer i ≥ 1, Nj(u), j ∈ {1, . . . , i} have been determined.
Let Ni+1(u) denote the set of nodes w ∈ V where w / ∈ S j∈{1,...,i} Nj(u) and w is adjacent to a node in Ni(u) − S.
Since there are a finite number of nodes, there can be only a finite number of sets generated this way.
Suppose we have h sets generated this way: N1(u), . . . , N h (u).
We call Ni(u), i ∈ {1, . . . , h}, the path sets of node u. Let un = | S i∈{1,...,h} Ni(u)−S|+1.
Select any un elements of {4, . . . , n} and label them as i1, i2, . . . , iu n so that i1 < i2 < . . . < iu n .
We construct a "complete sweep" for u as follows.
Assign indices 1 to 3 to nodes in S in any manner, and assign index iu n to node u. And so on.
Assign the indices in {4, . . . , n} − {i1, . . . , iu n } to the remaining nodes in any manner.
The resulting ordering c1, . . . , cn is a sweep since the nodes in S precede all other nodes, and node u is adjacent to at least one node preceding it.
We call this ordering a complete sweep for u.LEMMA 2.
Let u ∈ V −S, and suppose u has path sets N1(u), N2(u), . . . , N h (u).
i∈{1,...,h} Ni(u) is equal to the set of all nodes x ∈ V that is either adjacent to u or has a path x1, . . . , xm to u, where xi ∈ V − S, i ∈ {1, . . . , m}.
is the subgraph of G induced by u and all nodes x ∈ V that is either adjacent to u or has a path x1, . . . , xm to u, where xi ∈ V − S, i ∈ {1, . . . , m}.
Consider the subgraph H of G induced by nodes in V − S. Let H1, . . . , Hm be the maximally connected components of H. Let ui be a node of Hi for each i ∈ {1, . . . , m}.
Construct a complete sweep for u1, then use the left over indices to construct a complete sweep for u2, and so on.
We call the resulting sweep a complete sweep of the network, and we say that the sweep is based on u1, . . . , um.
Lemmas 1 and 2 can be used to show the following:LEMMA 3.
Select two sweeps, the first of which is the bilateration ordering [v] of G, and the second of which is a complete sweep of the network.
Let u1, . . . , um be the nodes on which the complete sweep is based.1.
S(ui, 2) is a singleton for all i = 1, . . . , m.2.
Suppose S(ui, 2) = {(pi, αp i )} for i ∈ {1, . . . , m}.
Define the assignment α : V → R 2 as α(w) = αp i (w) if w ∈ D(αp i ).
Then α is well defined, and ||α(w) − α(x)|| = dwx for all adjacent nodes w and x in G.A direct consequence of Lemma 3 is the following: THEOREM 1.
A localizable bilateration network N can be localized by the Sweeps algorithm in two sweeps, the first of which is a bilateration ordering, and the second of which is a complete sweep of the network, followed by an Euclidean transformation using anchor positions.
We first evaluate the performance of Sweeps with precise distance measurements.
We generate uniformly random networks of 250 nodes in a square region.
We do not consider anchors, as we are interested here in how many nodes Sweeps can localize.
In all our measurements, we aggregate the results from 100 network instances at each sensing radius and compute 95th-percentile confidence intervals for each quantity of interest.We use sensing range to control the density and connectivity of the network.
In random networks, there is a sensing radius r which ensures k-connectivity as well as trilaterability with high probability [3].
This is important because 3-connectivity is a necessary condition for unique localizability.
The results of this section all stem from the fact that an average degree will ensure bilaterability with a certain (possibly low) probability, but this average degree is lower than that required for trilaterability with the same probability.
figure, we first identify all theoretically uniquely localizable nodes by finding the globally rigid components.
Then we start a sweep at a random edge in the largest globally rigid component.
The number of uniquely localizable nodes swept by our algorithm is labeled as Swept.
From this figure, it is clear that the number of swept nodes is very close to the number of uniquely localizable nodes.
Our algorithm also identifies nodes with finite but not uniquely determined positions.
These nodes are labeled as Finite.
For comparison, this figure also plots the number of nodes whose positions are determined by iterated trilateration.
We observe that our algorithm significantly outperforms trilateration.
The performance gap between our algorithm and trilateration is highlighted in Figure 8.
We find that iterated trilateration always localizes fewer nodes than a sweep started at the same nodes because a trilateration network is necessarily a bilateration network but the converse is not true.
Specifically, Sweeps localizes at least 90% of uniquely localizable nodes with high confidence in random networks when the network density varies in a wide range.
For comparison, trilateration guarantees localization of only 40% of nodes.
Most sequential algorithms operate only on trilateration graphs [28], so to the best of our knowledge, no such algorithm succeeds in localizing more nodes than Sweeps.
Figure 8 also illustrates the transition from non-localizable to localizable and sweepable networks.
At around average degree 6 to 8, Sweeps localizes a lower proportion of localizable nodes than it does elsewhere.
It was observed and theoretically justified in [17] that this is the connectivity level at which networks start making the transition from containing many small globally rigid components to a single large component.
At this density, large globally rigid components start to absorb small peripheral components, and non-bilaterable structures appear at the edges of the globally rigid component.
Even in this problematic regime, the extent of localization remains around 90%.
As worst-case exponential computational complexity is a potential concern, we test the running time of Sweeps.
We found that potential exponential growth in possibilities rarely develops to a point where the algorithm fails to complete in minutes on a consumer PC even for networks of a thousand nodes.
At a given density, typically, the running time of Sweeps grows linearly with increasing number of nodes.
It localizes more than 95% of uniquely localizable nodes in a network of one-thousand nodes with average degree less than five in two minutes on a consumer PC with an Intel Xeon CPU of 2.80 GHz.
Thus, a potentially more serious problem is state keeping.
We run Sweeps and keep track of the maximum number of possibilities kept at any time for any node over the course of the algorithm, the mean number of possibilities kept for all nodes, and the 95th percentile number of possibilities.
These numbers are presented in Figure 9.
We observe that on these 250-node networks, the total number of possibilities maintained by the algorithm per node is less than 50 with high confidence.
While we will not show the results here, we also tracked the average number of possibilities kept per node as network size increased while holding average degree constant at 6, and found that this quantity remained constant over the entire range tested.
Intermediate densities around the above-mentioned transition between many small globally rigid clusters and a single globally rigid component again prove the most challenging for the algorithm.
At this density, even though we sweep on a uniquely localizable component, there are sometimes a few shells over which several bilaterations take place consecutively without any redundant edges to eliminate possibilities.
In Figure 10, we see further verification of the efficiency of Sweeps.
For the most difficult density of around average degree 6, 90% of nodes never have more than 8 possibilities.
Less than 0.5% ever have more than 256 possible positions.
We also run our simulations on anisotropic networks in which 250 nodes are randomly deployed in a ring around a large opaque rectangular obstacle which occupies one-half of the deployment In this section, we consider localization on regularly deployed networks.
Random deployment can have unpredictable spatial coverage and localizability due to local non-uniformity in node placement.In order to study localization on regular networks, we implement a mobility control rule that allows us to eliminate empty regions in the network and achieve a target average node degree.
We initially deploy nodes randomly at a high density and then evolve the network to achieve the target average node degree uniformly.
The details of the mobility scheme are specified in Appendix B.
The standard deviation in node degree after mobility control is consistently less than half of that of a network randomly deployed across the same region.
One might think that regular networks would be straightforward to localize, but this turns out not to be the case.
For instance, at low density, the near-symmetries which appear can make localization more difficult for global optimization approaches by making local minima more likely.
On uniquely localizable unions of wheel networks (a honeycomb pattern), SDP localization often outputs a flip configuration even with no noise present in the distance measurements.
As we saw before and will soon see again, sequential approaches based on trilateration networks are also likely ineffective on sparse regularly deployed networks, especially wheel networks.
We see in Figure 13 that at varying regular network density, the proportion of localizable nodes which are trilaterable is very low even at high density, while Sweeps is again effective.
The performance gap between our algorithm and that of trilateration on regular networks is highlighted in Figure 14.
We observe that Sweeps is still effective, while the performance of trilateration is extremely poor.
If we compare these results with those for random networks in Figure 8, we can see that Sweeps is more effective in regular networks, while trilateration-based approaches and global optimization are less effective in this setting.
Finally, we evaluate the performance of the version of our Sweeps algorithm adapted for noisy distance measurements.
We add zeromean Gaussian noise with standard deviation of 1, 5, and 15% of the sensing range to all distance measurements.
2 The number of shells upon which our algorithm successfully localizes nodes depends on the magnitude of the distance errors.
We have found that the localization out to five shells is robust to flip configurations at the noise levels tested.
In evaluation on those networks upon which global optimization approaches tend to do poorly, we find that Sweeps remains effective.
On non-convex deployments where MDS struggles, Sweeps 2 We do not consider the case in which there may be severe outliers in distance measurements.
This is a challenging problem that has begun to be investigated by Berger et al. [6].
computes good position estimates, as shown in Figure 15.
Recent improvements to MDS [24] improve the estimation of the complete distance matrix, but do so by bootstrapping from anchor positions.
Sweeps requires no anchors, and we have simulated the anchor-free case.
On regular deployments where SDP usually produces a flip configuration, Sweeps also succeeds, as shown in Figure 16.
Finally, we simulate Sweeps on random networks of 100 nodes and 5 anchors at an average degree of 8, with 5% Gaussian noise in all distance measurements.
We then start a sweep at each anchor and limit the depth of the sweep to five in order to avoid the possibility of large flip errors.
We find this approach effective, as localized nodes have lower estimation errors on average than nodes localized using MDS [37] or SDP [7], as shown in Figure 17.
This is partly due to the fact that Sweeps localizes only localizable nodes and avoids large errors due to unrecognized flip configurations.
Network localization is an active research field (e.g., [5,9,10,18,19,20,23,24,25,33,38]).
The previous approaches can be roughly classified into two types.
The first type is called coarsegrained or range free localization.
The focus of this paper is on the second type-fine-grained localization.
Thus, we review only previous work on fine-grained localization (e.g., [1,7,8,11,13,21,28,29,30,31,32,34,35,36,39]).
Eren et al. studied the theoretical conditions for fine-grained localization in [14,3,17].
These conditions are applied in various settings.
For instance, in [32], the authors proposed an algorithm using mobility to obtain distance measurements which result in globally rigid constraint structures.Many fine-grained localization algorithms are based on global optimization.
In particular, Biswas et al. applied semidefinite programming (SDP) to fine-grained localization [8,7].
Their algorithms are effective in relatively dense over-constrained networks.
Specifically, their algorithms require that Ω(n 2 ) pairs of nodes know their relative distances, where n is the number of sensor nodes in the network.
In sparse networks or networks with sparse subregions, their algorithms may not be able to correctly localize.
An alternative to SDP is multidimensional scaling (MDS) (e.g., [21,25,36]).
As we discussed in Section 1, MDS requires an initial estimation of the complete distance matrix, which may be available only in dense networks.
Neither SDP or MDS can identify all positions.The Sweeps algorithm belongs to the type of sequential localization algorithms.
Other sequential localization algorithms have been proposed before (e.g., [28,35]).
In particular, in [28], Moore et al. proposed a sequential localization algorithm based on trilateration graphs under noisy distance measurements.
However, their algorithm is effective only in relatively dense networks, while our Sweeps algorithm localizes a much larger class of network.In prior work [15,16], Fang et al. first proposed the idea of sweeping through a bilateration network in a sequential fashion.
In their algorithm, possibly non-consistent combinations of node positions were used to compute further possibilities.
In this paper we improve computational complexity using consistent position combinations and shell sweeps, extend the idea to handle angle and noisy measurements, and provide extensive evaluations.
Our work succeeds in provably localizing sparser networks.
One reason we believe this is an important contribution is that it extends, in practice, the class of networks for which feasible localization algorithms are known to those with little more than the minimum number of constraints necessary for any algorithm to succeed.
Since Sweeps is an incremental approach, it will be amenable to a distributed implementation, but we are leaving this for future work.We have also shown that our algorithm exhibits a synergy with a scheme for coverage-optimizing controlled mobility, resulting in a promising unified design for simultaneous spatial coverage, localizability optimization, and localization.
We envision joint controlled mobility-localization to be an eminently practical and effective network model with which to circumvent the inherent NPhardness of localization by altering network connectivity through mobility so as to be efficiently localizable by a particular algorithm.
Goldenberg and Yang was supported in part, by grants from the U.S. NSF.
Fang, Cao, and Morse was supported in part, by grants from the U.S. Army Research Office and the U.S. NSF and by a gift from the Xerox Corporation.
Bihler was supported by a grant from the German National Academic Foundation and the U.S. NSF.
Anderson was supported by an Australian Research Council Discovery Projects Grant and by National ICT Australia, which is funded by the Australian Government's Department of Communications, Information Technology and the Arts and Australian Research Council through the Backing Australia's Ability initiative and the ICT Centre of Excellence Program.
We are grateful to Jennifer Hou, our shepherd, for her help in revising the paper.
We are also grateful to the anonymous reviewers whose comments improve the paper.
X A. PROOFS OF LEMMA 1 AND LEMMA 2Proof of Lemma 1:1.
Suppose v ∈ G(u, [w] 2.
Suppose nodes a and b are adjacent nodes in G(u, [w]).
So suppose at least one of a or b is not in S, and without loss of generality, suppose a precedes b in [w].
Hence, there is a pathUsing the same logic as in part 1, we have that there exist 3.
This is direct consequence of the Sweeps algorithm.
2 Proof of Lemma 2:1.
Suppose x ∈ S i∈{1,...,h} Ni(u).
This implies x ∈ Ni(u) for some i ∈ {1, . . . , h}.
Hence x is either adjacent to u or to some xi−1 ∈ Ni−1(u) − S. Similarly xi−1 is either adjacent to u or to some xi−2 ∈ Ni−2(u) − S. And so on until we get x1 ∈ N1(u) − S.
So either x is adjacent to u or there is a path xi−1, xi−2, . . . , x1 from x to u where xj ∈ V − S for all j ∈ {1, . . . , i − 1}.
Suppose x is adjacent to u.
Then x ∈ N1(u).
Now suppose x ∈ V has a path xm, xm−1, . . . , x1 to u where xj ∈ V − S, for all j ∈ {1, . . . , m}.
By definition of path sets , x1 ∈ N1(u) since it is adjacent to u.
Since x1 ∈ N1(u) − S, we have that x2 ∈ S i=1,2 Ni(u) since x1 and x2 are adjacent.,...,h} Ni(u) since x is adjacent to xm and xm ∈ S i∈{1,...,h} Ni(u) and xm / ∈ S.2.
We showed above that S i∈{1,...,h} Ni(u) is equal to the set of all nodes x ∈ V that is either adjacent to u or has a path x1, . . . , xm to u where xi ∈ V − S, i ∈ {1, . . . , m}.
Hence, we just have to show that G(u, [c]) and S i∈{1,...,h} Ni(u) ∪ {u} contain the same nodes.must be adjacent to u or to some x k−2 ∈ N k−2 (u) − S, and so on.
If x is adjacent to u, then the index of x in [c] must precede that of u by construction of the complete sweep.
Hence x ∈ G(u, [c]).
If x is not adjacent to u, then there is a path x k−1 , . . . , x1 from x to u where xi ∈ Ni(u) − S for all i ∈ {1, . . . , k − 1}.
By definition of the complete sweep, we know that the indices assigned to nodes in Na(u) − S must be greater than all the indices assigned to nodes in N b (u) − S if a < b, and the index assigned to u is greater than the index assigned to any node in S i∈{1,...,h} Ni(u).
Therefore, there is a path [c]).
Now suppose x ∈ G(u, [c]) and x 񮽙 = u.
If x / ∈ S, then it follows from the definition of G(u, [c]) and part 1 above that x ∈ S i∈{1,...,h} Ni(u).
Suppose x ∈ S.
The localizability of N implies that each x ∈ S must have a path to u that does not include any other node in S. Hence, it follows from part 1 that x ∈ S i∈{1,...,h} Ni(u).
2 B. MOBILITY CONTROL SCHEME FOR COVERAGEAnother motivation for studying localization algorithms for sparse networks is the joint objective to improve the coverage of the network where the coverage of a network is defined to be the union of the coverage of each node in the network.
A dense network may be relatively easy to localize, but its coverage is reduced because nodes are placed near to each other to guarantee the network's density while they should spread out to improve the network's coverage.
To dynamically improve the network's coverage, we propose a simple but effective distributed method that guides each node's movements using only its distance measurements to its neighbors.Consider a connected network of mobile agents each of which has a sensor with sensing radius R.
We say agent j is a neighbor of agent i if agent j is within sensing range of agent i. Recently, in studying the coordinated dispersion of groups of mobile agents, one mobility control rule has been studied requiring that each robot moves away from its nearest neighbor.
Using the notion of generalized gradient and tools from computational geometry and nonsmooth analysis, it has been proven rigorously in [12] that this rule can spread the agents out in a bounded area and each agent's location will converge exponentially fast to its equilibrium point.
The efficiency, robustness and scalability of this rule has been tested using mobile robots [27].
This fully distributed rule cannot be directly used in the coverage control of mobile sensor networks due to two reasons: (i) it is assumed in [12,27] that each node knows the exact location of its nearest neighbor all the time even when all the nodes are in constant movement; and (ii) this rule ignores consequences of breaking established links which may result in an undesirable disconnected network.We will first modify the above rule to make it independent of the location information.
Let ni(t) denote the number of neighbors of node i at time t. For any node i, when it decides to move away from its nearest neighbor after acquiring its current distance to its neighbors, it moves in a random direction with a tentative small step and measures its distances to its neighbors again.
If its distance to its nearest neighbor increases, it moves in its current direction with a normal step; otherwise, it moves in the opposite direction with a normal step.
Note that in this way, each node is moving in a direction of the sub-gradient of its distance to its nearest neighbor once it moves with a normal step.
Note also that if node i is installed with a compass that can tell in which directions its neighbors are located, it can always know the exact gradient direction of the distance to its nearest neighbor.
Now we will consider how to preserve the network connectivity.
This is achieved by two means.
One is to keep each node updated about the average connectivity of the network, denoted by ¯ n; and the other is to keep the nodes on the boundary fixed if its number of neighbors is below a predefined threshold.
We will take the following conservative approach to make each node aware of the fact that it may be on the boundary of the network.
Let covi(t) denote the local convex hull of agent i at time t which is the convex hull of the positions of agent i and its neighbors at time t.
It can be proved [26] that if a node i is on the boundary, it must be a vertex of covi(t).
Furthermore, in most of the cases, if a node i is a vertex of covi(t), it is possible for the node to find a direction in which it moves away from all its neighbors.
Note again that if node i is installed with a compass, it can know it is a vertex of covi(t) if there exists a line passing through node i such that all its neighbors live in the same half-plane.
The mobility control law described above is shown in Figure 18.
while ¯ n > 3 if agent i is a vertex of covi(ti) and ni(ti) ≤ 3 Do not move.
elseMove away from the nearest neighbor.
Proof of Lemma 1:1.
Suppose v ∈ G(u, [w] 2.
Suppose nodes a and b are adjacent nodes in G(u, [w]).
So suppose at least one of a or b is not in S, and without loss of generality, suppose a precedes b in [w].
Hence, there is a pathUsing the same logic as in part 1, we have that there exist 3.
This is direct consequence of the Sweeps algorithm.
2 1.
Suppose x ∈ S i∈{1,...,h} Ni(u).
This implies x ∈ Ni(u) for some i ∈ {1, . . . , h}.
Hence x is either adjacent to u or to some xi−1 ∈ Ni−1(u) − S. Similarly xi−1 is either adjacent to u or to some xi−2 ∈ Ni−2(u) − S. And so on until we get x1 ∈ N1(u) − S.
So either x is adjacent to u or there is a path xi−1, xi−2, . . . , x1 from x to u where xj ∈ V − S for all j ∈ {1, . . . , i − 1}.
Suppose x is adjacent to u.
Then x ∈ N1(u).
Now suppose x ∈ V has a path xm, xm−1, . . . , x1 to u where xj ∈ V − S, for all j ∈ {1, . . . , m}.
By definition of path sets , x1 ∈ N1(u) since it is adjacent to u.
Since x1 ∈ N1(u) − S, we have that x2 ∈ S i=1,2 Ni(u) since x1 and x2 are adjacent.,...,h} Ni(u) since x is adjacent to xm and xm ∈ S i∈{1,...,h} Ni(u) and xm / ∈ S.2.
We showed above that S i∈{1,...,h} Ni(u) is equal to the set of all nodes x ∈ V that is either adjacent to u or has a path x1, . . . , xm to u where xi ∈ V − S, i ∈ {1, . . . , m}.
Hence, we just have to show that G(u, [c]) and S i∈{1,...,h} Ni(u) ∪ {u} contain the same nodes.must be adjacent to u or to some x k−2 ∈ N k−2 (u) − S, and so on.
If x is adjacent to u, then the index of x in [c] must precede that of u by construction of the complete sweep.
Hence x ∈ G(u, [c]).
If x is not adjacent to u, then there is a path x k−1 , . . . , x1 from x to u where xi ∈ Ni(u) − S for all i ∈ {1, . . . , k − 1}.
By definition of the complete sweep, we know that the indices assigned to nodes in Na(u) − S must be greater than all the indices assigned to nodes in N b (u) − S if a < b, and the index assigned to u is greater than the index assigned to any node in S i∈{1,...,h} Ni(u).
Therefore, there is a path [c]).
Now suppose x ∈ G(u, [c]) and x 񮽙 = u.
If x / ∈ S, then it follows from the definition of G(u, [c]) and part 1 above that x ∈ S i∈{1,...,h} Ni(u).
Suppose x ∈ S.
The localizability of N implies that each x ∈ S must have a path to u that does not include any other node in S. Hence, it follows from part 1 that x ∈ S i∈{1,...,h} Ni(u).
2 Another motivation for studying localization algorithms for sparse networks is the joint objective to improve the coverage of the network where the coverage of a network is defined to be the union of the coverage of each node in the network.
A dense network may be relatively easy to localize, but its coverage is reduced because nodes are placed near to each other to guarantee the network's density while they should spread out to improve the network's coverage.
To dynamically improve the network's coverage, we propose a simple but effective distributed method that guides each node's movements using only its distance measurements to its neighbors.Consider a connected network of mobile agents each of which has a sensor with sensing radius R.
We say agent j is a neighbor of agent i if agent j is within sensing range of agent i. Recently, in studying the coordinated dispersion of groups of mobile agents, one mobility control rule has been studied requiring that each robot moves away from its nearest neighbor.
Using the notion of generalized gradient and tools from computational geometry and nonsmooth analysis, it has been proven rigorously in [12] that this rule can spread the agents out in a bounded area and each agent's location will converge exponentially fast to its equilibrium point.
The efficiency, robustness and scalability of this rule has been tested using mobile robots [27].
This fully distributed rule cannot be directly used in the coverage control of mobile sensor networks due to two reasons: (i) it is assumed in [12,27] that each node knows the exact location of its nearest neighbor all the time even when all the nodes are in constant movement; and (ii) this rule ignores consequences of breaking established links which may result in an undesirable disconnected network.We will first modify the above rule to make it independent of the location information.
Let ni(t) denote the number of neighbors of node i at time t. For any node i, when it decides to move away from its nearest neighbor after acquiring its current distance to its neighbors, it moves in a random direction with a tentative small step and measures its distances to its neighbors again.
If its distance to its nearest neighbor increases, it moves in its current direction with a normal step; otherwise, it moves in the opposite direction with a normal step.
Note that in this way, each node is moving in a direction of the sub-gradient of its distance to its nearest neighbor once it moves with a normal step.
Note also that if node i is installed with a compass that can tell in which directions its neighbors are located, it can always know the exact gradient direction of the distance to its nearest neighbor.
Now we will consider how to preserve the network connectivity.
This is achieved by two means.
One is to keep each node updated about the average connectivity of the network, denoted by ¯ n; and the other is to keep the nodes on the boundary fixed if its number of neighbors is below a predefined threshold.
We will take the following conservative approach to make each node aware of the fact that it may be on the boundary of the network.
Let covi(t) denote the local convex hull of agent i at time t which is the convex hull of the positions of agent i and its neighbors at time t.
It can be proved [26] that if a node i is on the boundary, it must be a vertex of covi(t).
Furthermore, in most of the cases, if a node i is a vertex of covi(t), it is possible for the node to find a direction in which it moves away from all its neighbors.
Note again that if node i is installed with a compass, it can know it is a vertex of covi(t) if there exists a line passing through node i such that all its neighbors live in the same half-plane.
The mobility control law described above is shown in Figure 18.
while ¯ n > 3 if agent i is a vertex of covi(ti) and ni(ti) ≤ 3 Do not move.
elseMove away from the nearest neighbor.
